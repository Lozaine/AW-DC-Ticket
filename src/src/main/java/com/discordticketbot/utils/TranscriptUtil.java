package com.discordticketbot.utils;

import net.dv8tion.jda.api.entities.Message;
import net.dv8tion.jda.api.entities.MessageEmbed;
import net.dv8tion.jda.api.entities.MessageReaction;
import net.dv8tion.jda.api.entities.channel.concrete.TextChannel;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TranscriptUtil {

    // Use UTC+08:00 timezone (Malaysia/Singapore timezone)
    private static final ZoneOffset TIMEZONE_OFFSET = ZoneOffset.ofHours(8);
    private static final String TIMEZONE_SUFFIX = " UTC+08:00";

    // Pattern to match Discord timestamp format <t:timestamp:format>
    private static final Pattern DISCORD_TIMESTAMP_PATTERN = Pattern.compile("<t:(\\d+):[FfDdTtRr]>");
    private static final DateTimeFormatter TRANSCRIPT_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    public static String createTranscriptContent(TextChannel channel, List<Message> messages) {
        StringBuilder transcript = new StringBuilder();

        transcript.append("=== DISCORD TICKET TRANSCRIPT ===\n");
        transcript.append("Server: ").append(channel.getGuild().getName()).append("\n");
        transcript.append("Channel: ").append(channel.getName()).append("\n");
        transcript.append("Category: ").append(channel.getParentCategory() != null ? channel.getParentCategory().getName() : "None").append("\n");
        transcript.append("Total Messages: ").append(messages.size()).append("\n");
        transcript.append("Generated: ").append(LocalDateTime.now(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER)).append(TIMEZONE_SUFFIX).append("\n");
        transcript.append("Generated by: Bot System\n");
        transcript.append("=====================================\n\n");

        for (int i = messages.size() - 1; i >= 0; i--) {
            Message msg = messages.get(i);
            // Convert message timestamp to UTC+08:00 and format consistently
            String timestamp = msg.getTimeCreated().atZoneSameInstant(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER);
            transcript.append(String.format("[%s%s] %s: %s\n", timestamp, TIMEZONE_SUFFIX, msg.getAuthor().getName(), msg.getContentDisplay()));

            if (!msg.getEmbeds().isEmpty()) {
                for (MessageEmbed embed : msg.getEmbeds()) {
                    transcript.append("    [EMBED] Title: ").append(embed.getTitle() != null ? embed.getTitle() : "No Title").append("\n");
                    if (embed.getDescription() != null) {
                        // Convert Discord timestamps in embed descriptions to readable format
                        String description = convertDiscordTimestamps(embed.getDescription());
                        transcript.append("    [EMBED] Description: ").append(description).append("\n");
                    }
                }
            }

            if (!msg.getAttachments().isEmpty()) {
                for (Message.Attachment attachment : msg.getAttachments()) {
                    transcript.append("    [ATTACHMENT] ").append(attachment.getFileName())
                            .append(" (").append(formatFileSize(attachment.getSize())).append(")")
                            .append(" - ").append(attachment.getUrl()).append("\n");
                }
            }

            if (!msg.getReactions().isEmpty()) {
                transcript.append("    [REACTIONS] ");
                for (MessageReaction reaction : msg.getReactions()) {
                    transcript.append(reaction.getEmoji().getName()).append(":").append(reaction.getCount()).append(" ");
                }
                transcript.append("\n");
            }

            transcript.append("\n");
        }

        transcript.append("=== END OF TRANSCRIPT ===\n");
        return transcript.toString();
    }

    /**
     * Appends close request information to the transcript if available.
     * This is a placeholder method and would need to interact with your database
     * to fetch close request details for the given channel ID.
     *
     * @param channelId The ID of the channel to get close request info for.
     * @param transcript The StringBuilder to append the information to.
     */
    private static void appendCloseRequestInfo(String channelId, StringBuilder transcript) {
        // TODO: Implement logic to fetch and append close request details from your database.
        // Example:
        // CloseRequestData data = database.getCloseRequest(channelId);
        // if (data != null) {
        //     transcript.append("Close Request Info:\n");
        //     transcript.append("  Requested by: ").append(data.getStaffName()).append("\n");
        //     transcript.append("  Reason: ").append(data.getReason()).append("\n");
        //     transcript.append("  Requested at: ").append(data.getRequestTimestamp().format(TRANSCRIPT_FORMATTER)).append(TIMEZONE_SUFFIX).append("\n");
        //     if (data.getTimeoutHours() > 0) {
        //         transcript.append("  Auto-close timeout: ").append(data.getTimeoutHours()).append(" hours\n");
        //     }
        //     if (data.isExcludedFromAutoClose()) {
        //         transcript.append("  Excluded from auto-close: Yes\n");
        //     }
        // }
    }


    /**
     * Converts Discord timestamp format <t:timestamp:format> to readable datetime format
     * Example: <t:1755879938:F> becomes "2025-08-23 09:33:04 UTC+08:00"
     */
    private static String convertDiscordTimestamps(String text) {
        if (text == null) return null;

        Matcher matcher = DISCORD_TIMESTAMP_PATTERN.matcher(text);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            try {
                long timestamp = Long.parseLong(matcher.group(1));
                LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochSecond(timestamp), TIMEZONE_OFFSET);
                String formattedDate = dateTime.format(TRANSCRIPT_FORMATTER) + TIMEZONE_SUFFIX;
                matcher.appendReplacement(result, formattedDate);
            } catch (NumberFormatException e) {
                // If parsing fails, keep the original timestamp
                matcher.appendReplacement(result, matcher.group(0));
            }
        }
        matcher.appendTail(result);

        return result.toString();
    }

    public static File saveTranscriptToFile(TextChannel channel, String content) throws IOException {
        File transcriptsDir = new File("transcripts");
        if (!transcriptsDir.exists()) transcriptsDir.mkdirs();

        String fileName = String.format("%s_%s.txt",
                channel.getName(),
                LocalDateTime.now(TIMEZONE_OFFSET).format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss")));

        File transcriptFile = new File(transcriptsDir, fileName);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(transcriptFile))) {
            writer.write(content);
        }
        System.out.println("Transcript saved: " + transcriptFile.getAbsolutePath());
        return transcriptFile;
    }

    private static String formatFileSize(long size) {
        if (size < 1024) return size + " B";
        if (size < 1024 * 1024) return String.format("%.1f KB", size / 1024.0);
        return String.format("%.1f MB", size / (1024.0 * 1024.0));
    }
}