package com.discordticketbot.utils;

import com.discordticketbot.database.CloseRequestDAO;
import net.dv8tion.jda.api.entities.Message;
import net.dv8tion.jda.api.entities.MessageEmbed;
import net.dv8tion.jda.api.entities.MessageReaction;
import net.dv8tion.jda.api.entities.channel.concrete.TextChannel;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TranscriptUtil {

    // Use UTC+08:00 timezone (Malaysia/Singapore timezone)
    private static final ZoneOffset TIMEZONE_OFFSET = ZoneOffset.ofHours(8);
    private static final String TIMEZONE_SUFFIX = " UTC+08:00";

    // Pattern to match Discord timestamp format <t:timestamp:format>
    private static final Pattern DISCORD_TIMESTAMP_PATTERN = Pattern.compile("<t:(\\d+):[FfDdTtRr]>");
    private static final DateTimeFormatter TRANSCRIPT_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    // Server management
    private static final ConcurrentHashMap<String, SimpleHttpServer> activeServers = new ConcurrentHashMap<>();
    private static final ScheduledExecutorService serverCleanupExecutor = Executors.newSingleThreadScheduledExecutor();

    /**
     * Creates a plain text transcript content from channel messages.
     * Enhanced to include close request details and better formatting.
     */
    public static String createTranscriptContent(TextChannel channel, List<Message> messages) {
        StringBuilder transcript = new StringBuilder();

        // Sort messages to be in chronological order (oldest first)
        List<Message> sortedMessages = messages.stream()
                .sorted((m1, m2) -> m1.getTimeCreated().compareTo(m2.getTimeCreated()))
                .toList();

        // Header
        transcript.append("=== DISCORD TICKET TRANSCRIPT ===\n");
        transcript.append("Server: ").append(channel.getGuild().getName()).append("\n");
        transcript.append("Channel: ").append(channel.getName()).append("\n");
        transcript.append("Category: ").append(channel.getParentCategory() != null ? channel.getParentCategory().getName() : "None").append("\n");
        transcript.append("Total Messages: ").append(sortedMessages.size()).append("\n");
        transcript.append("Generated: ").append(LocalDateTime.now(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER)).append(TIMEZONE_SUFFIX).append("\n");
        transcript.append("Generated by: Bot System\n");

        // Add close request information if available
        appendCloseRequestInfo(channel.getId(), transcript);

        transcript.append("=====================================\n\n");

        // Messages
        for (Message msg : sortedMessages) {
            String timestamp = msg.getTimeCreated().atZoneSameInstant(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER);
            transcript.append(String.format("[%s%s] %s: %s\n", timestamp, TIMEZONE_SUFFIX, msg.getAuthor().getName(), processMessageContent(msg.getContentDisplay())));

            if (!msg.getEmbeds().isEmpty()) {
                for (MessageEmbed embed : msg.getEmbeds()) {
                    transcript.append("    [EMBED] Title: ").append(embed.getTitle() != null ? embed.getTitle() : "No Title").append("\n");
                    if (embed.getDescription() != null) {
                        String description = convertDiscordTimestamps(embed.getDescription());
                        // Enhanced parsing for close requests
                        description = enhanceCloseRequestInfo(description);
                        transcript.append("    [EMBED] Description: ").append(description).append("\n");
                    }

                    // Process embed fields for additional close request details
                    if (!embed.getFields().isEmpty()) {
                        for (MessageEmbed.Field field : embed.getFields()) {
                            if (field.getName() != null && field.getValue() != null) {
                                transcript.append("    [EMBED] ").append(field.getName()).append(": ").append(field.getValue()).append("\n");
                            }
                        }
                    }
                }
            }

            if (!msg.getAttachments().isEmpty()) {
                for (Message.Attachment attachment : msg.getAttachments()) {
                    transcript.append("    [ATTACHMENT] ").append(attachment.getFileName())
                            .append(" (").append(getReadableFileSize(attachment.getSize())).append(")")
                            .append(" - ").append(attachment.getUrl()).append("\n");
                }
            }

            if (!msg.getReactions().isEmpty()) {
                transcript.append("    [REACTIONS] ");
                for (MessageReaction reaction : msg.getReactions()) {
                    transcript.append(reaction.getEmoji().getName()).append(":").append(reaction.getCount()).append(" ");
                }
                transcript.append("\n");
            }
            transcript.append("\n");
        }

        // Footer
        transcript.append("=== END OF TRANSCRIPT ===\n");
        return transcript.toString();
    }

    /**
     * Saves the plain text transcript to a file.
     */
    public static File saveTranscriptToFile(TextChannel channel, String content) throws IOException {
        File transcriptsDir = new File("transcripts");
        if (!transcriptsDir.exists()) transcriptsDir.mkdirs();

        String fileName = String.format("%s_%s.txt",
                channel.getName(),
                LocalDateTime.now(TIMEZONE_OFFSET).format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss")));

        File transcriptFile = new File(transcriptsDir, fileName);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(transcriptFile))) {
            writer.write(content);
        }
        System.out.println("Transcript saved: " + transcriptFile.getAbsolutePath());
        return transcriptFile;
    }

    /**
     * Create HTML transcript (more advanced formatting).
     */
    public static String createHtmlTranscript(TextChannel channel, List<Message> messages) {
        StringBuilder html = new StringBuilder();

        List<Message> sortedMessages = messages.stream()
                .sorted((m1, m2) -> m1.getTimeCreated().compareTo(m2.getTimeCreated()))
                .toList();

        // HTML header and CSS styles
        html.append("<!DOCTYPE html>\n<html>\n<head>\n");
        html.append("<meta charset='UTF-8'>\n");
        html.append("<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n");
        html.append("<title>Ticket Transcript - ").append(escapeHtml(channel.getName())).append("</title>\n");
        html.append("<style>\n");
        html.append("body { font-family: 'Segoe UI', Arial, sans-serif; background: #36393f; color: #dcddde; margin: 0; padding: 20px; line-height: 1.6; }\n");
        html.append(".container { max-width: 1000px; margin: 0 auto; }\n");
        html.append(".header { background: #2f3136; padding: 20px; border-radius: 8px; margin-bottom: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }\n");
        html.append(".toolbar { display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0 20px; }\n");
        html.append(".btn { background: #5865f2; color: white; border: none; text-decoration: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px; display: inline-block; }\n");
        html.append(".btn.secondary { background: #2f3136; }\n");
        html.append(".btn:hover { opacity: 0.9; }\n");
        html.append(".close-info { background: #5865f2; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }\n");
        html.append(".message { margin-bottom: 15px; padding: 10px; background: #40444b; border-radius: 8px; box-shadow: 0 1px 5px rgba(0,0,0,0.1); }\n");
        html.append(".author { font-weight: bold; color: #ffffff; margin-bottom: 5px; display: flex; align-items: center; gap: 8px; }\n");
        html.append(".timestamp { color: #72767d; font-size: 12px; }\n");
        html.append(".content { margin-top: 5px; line-height: 1.4; word-wrap: break-word; }\n");
        html.append(".bot-tag { background: #5865f2; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: normal; }\n");
        html.append(".embed { border-left: 4px solid #5865f2; padding: 10px; margin: 10px 0; background: #2f3136; border-radius: 4px; }\n");
        html.append(".embed-close { border-left: 4px solid #f23c43; }\n");
        html.append(".embed-open { border-left: 4px solid #57f287; }\n");
        html.append(".attachment { color: #00b0f4; text-decoration: none; display: inline-block; padding: 5px 10px; background: #2f3136; border-radius: 4px; margin: 5px 0; }\n");
        html.append(".attachment:hover { background: #36393f; }\n");
        html.append(".close-reason { background: #f23c43; padding: 8px; border-radius: 4px; margin: 5px 0; }\n");
        html.append(".timeout-info { background: #faa61a; color: #000; padding: 8px; border-radius: 4px; margin: 5px 0; }\n");
        html.append(".reactions { margin-top: 10px; }\n");
        html.append(".reaction { background: #2f3136; padding: 4px 8px; border-radius: 12px; display: inline-block; margin-right: 5px; font-size: 12px; }\n");
        html.append("@media (max-width: 768px) { body { padding: 10px; } .container { padding: 0; } }\n");
        html.append("</style>\n");
        html.append("</head>\n<body>\n");
        html.append("<div class='container'>\n");

        // Header
        html.append("<div class='header'>\n");
        html.append("<h1>🎫 Ticket Transcript</h1>\n");
        html.append("<p><strong>Channel:</strong> #").append(escapeHtml(channel.getName())).append(" (").append(channel.getId()).append(")</p>\n");
        html.append("<p><strong>Guild:</strong> ").append(escapeHtml(channel.getGuild().getName())).append("</p>\n");
        html.append("<p><strong>Generated:</strong> ").append(LocalDateTime.now(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER)).append(TIMEZONE_SUFFIX).append("</p>\n");
        html.append("<p><strong>Total Messages:</strong> ").append(sortedMessages.size()).append("</p>\n");
        if (channel.getTopic() != null && !channel.getTopic().isEmpty()) {
            html.append("<p><strong>Ticket Owner:</strong> &lt;@").append(escapeHtml(channel.getTopic())).append("&gt;</p>\n");
        }
        html.append("</div>\n\n");

        // Add close request info section
        String closeRequestInfo = getCloseRequestInfoHtml(channel.getId());
        if (closeRequestInfo != null && !closeRequestInfo.isEmpty()) {
            html.append(closeRequestInfo);
        }

        // Messages
        for (Message message : sortedMessages) {
            html.append("<div class='message'>\n");
            html.append("<div class='author'>");
            html.append("<span>").append(escapeHtml(message.getAuthor().getName())).append("</span>");

            if (message.getAuthor().isBot()) {
                html.append(" <span class='bot-tag'>BOT</span>");
            }

            html.append("<span class='timestamp'>")
                    .append(message.getTimeCreated().atZoneSameInstant(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER))
                    .append(TIMEZONE_SUFFIX)
                    .append("</span></div>\n");

            String content = message.getContentDisplay();
            if (!content.isEmpty()) {
                // Remove "Please choose an action:" from content
                content = content.replaceAll("Please choose an action:", "").trim();
                if (!content.isEmpty()) {
                    html.append("<div class='content'>").append(escapeHtml(content)).append("</div>\n");
                }
            }

            for (var embed : message.getEmbeds()) {
                String embedClass = "embed";
                if (embed.getTitle() != null) {
                    if (embed.getTitle().contains("Closed") || embed.getTitle().contains("Close Request")) {
                        embedClass += " embed-close";
                    } else if (embed.getTitle().contains("Re-opened")) {
                        embedClass += " embed-open";
                    }
                }

                html.append("<div class='").append(embedClass).append("'>\n");
                if (embed.getTitle() != null) {
                    html.append("<strong>").append(escapeHtml(embed.getTitle())).append("</strong><br>\n");
                }
                if (embed.getDescription() != null) {
                    String description = convertDiscordTimestamps(escapeHtml(embed.getDescription()));
                    // Remove "Please choose an action:" from embed descriptions
                    description = description.replaceAll("Please choose an action:", "").trim();
                    if (!description.isEmpty()) {
                        html.append(description).append("<br>\n");
                    }
                }

                // Process embed fields
                for (var field : embed.getFields()) {
                    if (field.getName() != null && field.getValue() != null) {
                        String fieldName = field.getName();
                        String fieldValue = convertDiscordTimestamps(field.getValue());

                        if (fieldName.contains("Timeout") || fieldName.contains("Auto")) {
                            html.append("<div class='timeout-info'>");
                            html.append("<strong>").append(escapeHtml(fieldName)).append(":</strong> ");
                            html.append(escapeHtml(fieldValue));
                            html.append("</div>\n");
                        } else if (fieldName.contains("Reason")) {
                            html.append("<div class='close-reason'>");
                            html.append("<strong>").append(escapeHtml(fieldName)).append(":</strong> ");
                            html.append(escapeHtml(fieldValue));
                            html.append("</div>\n");
                        } else {
                            html.append("<strong>").append(escapeHtml(fieldName)).append(":</strong> ");
                            html.append(escapeHtml(fieldValue)).append("<br>\n");
                        }
                    }
                }
                html.append("</div>\n");
            }

            for (var attachment : message.getAttachments()) {
                html.append("<div class='content'>");
                html.append("<a href='").append(attachment.getUrl()).append("' class='attachment' target='_blank'>");
                html.append("📎 ").append(escapeHtml(attachment.getFileName()));
                html.append(" (").append(getReadableFileSize(attachment.getSize())).append(")");
                html.append("</a></div>\n");
            }

            if (!message.getReactions().isEmpty()) {
                html.append("<div class='reactions'>");
                for (MessageReaction reaction : message.getReactions()) {
                    html.append("<span class='reaction'>");
                    html.append(escapeHtml(reaction.getEmoji().getName())).append(" ").append(reaction.getCount());
                    html.append("</span>");
                }
                html.append("</div>\n");
            }
            html.append("</div>\n\n");
        }

        // Footer
        html.append("<div class='header'>\n");
        html.append("<p><em>Generated by Discord Ticket Bot System</em></p>\n");
        html.append("<p><small>This transcript will be available for viewing for a limited time.</small></p>\n");
        html.append("</div>\n");
        html.append("</div>\n"); // Close container
        // Toolbar with direct and download links
        html.append("<div class='toolbar'>\n");
        html.append("  <a class='btn' href='/transcript' target='_blank'>Open Direct Link</a>\n");
        html.append("  <a class='btn secondary' href='/download'>Download Transcript (HTML)</a>\n");
        html.append("  <button class='btn' id='copyLinkBtn'>Copy Link</button>\n");
        html.append("  <span id='copyStatus' style='display:none;margin-left:6px;'>Copied!</span>\n");
        html.append("</div>\n\n");
        // Simple script to copy the current URL
        html.append("<script>\n");
        html.append("(function(){\n");
        html.append("  var btn = document.getElementById('copyLinkBtn');\n");
        html.append("  if(btn){\n");
        html.append("    btn.addEventListener('click', function(){\n");
        html.append("      var url = window.location.href;\n");
        html.append("      navigator.clipboard && navigator.clipboard.writeText(url).then(function(){\n");
        html.append("        var s = document.getElementById('copyStatus'); if(s){ s.style.display='inline'; setTimeout(function(){ s.style.display='none'; }, 1500);}\n");
        html.append("      }).catch(function(){\n");
        html.append("        // Fallback copy\n");
        html.append("        var ta=document.createElement('textarea'); ta.value=url; document.body.appendChild(ta); ta.select(); try{document.execCommand('copy');}catch(e){} document.body.removeChild(ta);\n");
        html.append("        var s = document.getElementById('copyStatus'); if(s){ s.style.display='inline'; setTimeout(function(){ s.style.display='none'; }, 1500);}\n");
        html.append("      });\n");
        html.append("    });\n");
        html.append("  }\n");
        html.append("})();\n");
        html.append("</script>\n");
        html.append("</body>\n</html>");

        return html.toString();
    }

    /**
     * Saves the HTML transcript to a file.
     */
    public static File saveHtmlTranscriptToFile(TextChannel channel, String htmlContent) throws IOException {
        File transcriptsDir = new File("transcripts");
        if (!transcriptsDir.exists()) {
            transcriptsDir.mkdirs();
        }

        String timestamp = LocalDateTime.now(TIMEZONE_OFFSET).format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
        String filename = String.format("%s_%s_%s.html",
                channel.getName().replaceAll("[^a-zA-Z0-9-_]", "_"), // Sanitize filename
                channel.getId(),
                timestamp);

        File transcriptFile = new File(transcriptsDir, filename);

        try (FileWriter writer = new FileWriter(transcriptFile, java.nio.charset.StandardCharsets.UTF_8)) {
            writer.write(htmlContent);
        }

        System.out.println("✅ HTML transcript saved: " + transcriptFile.getAbsolutePath());
        return transcriptFile;
    }

    /**
     * Serves an HTML transcript file via HTTP server and returns the access URL.
     * This method creates or reuses an HTTP server for serving transcript files.
     * The server automatically shuts down after 2 hours or can be manually stopped.
     */
    public static String serveHtmlTranscript(File htmlFile, String channelName) {
        String serverId = "transcript-" + channelName + "-" + System.currentTimeMillis();
        
        try {
            // Stop any existing server for this channel (cleanup)
            String existingKey = activeServers.keySet().stream()
                    .filter(key -> key.contains(channelName))
                    .findFirst()
                    .orElse(null);
            
            if (existingKey != null) {
                SimpleHttpServer existingServer = activeServers.remove(existingKey);
                if (existingServer != null) {
                    existingServer.stop();
                    System.out.println("🧹 Stopped existing server for channel: " + channelName);
                }
            }

            // Find an available port
            int port = -1;
            try {
                String envPort = System.getenv("PORT");
                if (envPort != null && !envPort.isBlank()) {
                    port = Integer.parseInt(envPort.trim());
                }
            } catch (Exception ignored) {}
            if (port <= 0) {
                port = findAvailablePort();
            }
            if (port == -1) {
                throw new IOException("No available ports found");
            }

            // Create and start the server
            SimpleHttpServer server = new SimpleHttpServer(port, htmlFile, channelName);
            
            // Start server in background thread
            Thread serverThread = new Thread(() -> {
                try {
                    server.start();
                } catch (Exception e) {
                    System.err.println("❌ Error running HTTP server for " + channelName + ": " + e.getMessage());
                    activeServers.remove(serverId);
                }
            });
            serverThread.setDaemon(true);
            serverThread.start();

            // Wait for server to start
            int attempts = 0;
            while (!server.isRunning() && attempts < 50) {
                Thread.sleep(100);
                attempts++;
            }

            if (!server.isRunning()) {
                throw new IOException("Server failed to start within timeout");
            }

            activeServers.put(serverId, server);

            // Schedule automatic shutdown after 2 hours
            serverCleanupExecutor.schedule(() -> {
                SimpleHttpServer serverToStop = activeServers.remove(serverId);
                if (serverToStop != null) {
                    serverToStop.stop();
                    System.out.println("🕐 Auto-stopped transcript server for: " + channelName + " (2 hour timeout)");
                }
            }, 2, TimeUnit.HOURS);

            // Get the actual bound port
            int boundPort = server.getBoundPort();
            String host = getAccessibleHostAddress();
            
            String url = "http://" + host + ":" + boundPort + "/transcript";
            System.out.println("✅ Transcript server started for " + channelName + " at: " + url);
            
            return url;

        } catch (Exception e) {
            System.err.println("❌ Failed to serve HTML transcript for " + channelName + ": " + e.getMessage());
            // Clean up on failure
            activeServers.remove(serverId);
            // Return file URL as fallback
            return "file://" + htmlFile.getAbsolutePath().replace("\\", "/");
        }
    }

    /**
     * Stops all active transcript servers (cleanup method).
     */
    public static void stopAllTranscriptServers() {
        System.out.println("🧹 Stopping all active transcript servers...");
        activeServers.values().forEach(SimpleHttpServer::stop);
        activeServers.clear();
        System.out.println("✅ All transcript servers stopped");
    }

    /**
     * Get the count of active transcript servers.
     */
    public static int getActiveServerCount() {
        return activeServers.size();
    }

    /**
     * Finds an available port for the HTTP server.
     */
    private static int findAvailablePort() {
        int[] preferredPorts = {8080, 8081, 8082, 8083, 8084, 3000, 3001, 3002, 3003, 3004};
        
        // Try preferred ports first
        for (int port : preferredPorts) {
            try (java.net.ServerSocket socket = new java.net.ServerSocket(port)) {
                return port;
            } catch (IOException ignored) {
                // Port is busy, try next
            }
        }
        
        // If no preferred port is available, use system-assigned port
        try (java.net.ServerSocket socket = new java.net.ServerSocket(0)) {
            return socket.getLocalPort();
        } catch (IOException e) {
            System.err.println("❌ Failed to find any available port: " + e.getMessage());
            return -1;
        }
    }

    /**
     * Gets an accessible host address for external connections.
     */
    private static String getAccessibleHostAddress() {
        try {
            // Try to find a local network interface
            java.util.Enumeration<java.net.NetworkInterface> interfaces = java.net.NetworkInterface.getNetworkInterfaces();
            while (interfaces.hasMoreElements()) {
                java.net.NetworkInterface networkInterface = interfaces.nextElement();
                if (!networkInterface.isUp() || networkInterface.isLoopback()) continue;
                
                java.util.Enumeration<java.net.InetAddress> addresses = networkInterface.getInetAddresses();
                while (addresses.hasMoreElements()) {
                    java.net.InetAddress address = addresses.nextElement();
                    if (address instanceof java.net.Inet4Address && address.isSiteLocalAddress()) {
                        return address.getHostAddress();
                    }
                }
            }
            
            // Fallback to local host address
            return java.net.InetAddress.getLocalHost().getHostAddress();
        } catch (Exception e) {
            System.err.println("⚠️ Failed to determine accessible host address, using localhost: " + e.getMessage());
            return "127.0.0.1";
        }
    }

    /**
     * Appends close request information to the transcript if available.
     */
    private static void appendCloseRequestInfo(String channelId, StringBuilder transcript) {
        try {
            CloseRequestDAO closeRequestDAO = new CloseRequestDAO();
            CloseRequestDAO.CloseRequestDetails details = closeRequestDAO.getCloseRequestDetails(channelId);

            if (details != null) {
                transcript.append("\n=== CLOSE REQUEST DETAILS ===\n");
                transcript.append("Requested by: ").append(details.requestedBy).append("\n");
                transcript.append("Ticket owner: ").append(details.ticketOwner).append("\n");
                transcript.append("Reason: ").append(details.reason != null ? details.reason : "No reason provided").append("\n");

                if (details.timeoutHours != null) {
                    transcript.append("Auto-close timeout: ").append(details.timeoutHours).append(" hours\n");
                } else {
                    transcript.append("Auto-close timeout: Not set\n");
                }

                transcript.append("Status: ").append(details.status).append("\n");
                transcript.append("Created at: ").append(details.createdAt != null ?
                        details.createdAt.toLocalDateTime().atOffset(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER) + TIMEZONE_SUFFIX : "Unknown").append("\n");

                if (details.respondedAt != null) {
                    transcript.append("Responded at: ").append(
                            details.respondedAt.toLocalDateTime().atOffset(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER) + TIMEZONE_SUFFIX).append("\n");
                }

                if (details.respondedBy != null) {
                    transcript.append("Responded by: ").append(details.respondedBy).append("\n");
                }

                if (details.excludedFromAutoClose) {
                    transcript.append("Excluded from auto-close: Yes\n");
                }
            }
        } catch (Exception e) {
            transcript.append("\n=== CLOSE REQUEST DETAILS ===\n");
            transcript.append("Could not retrieve close request details: ").append(e.getMessage()).append("\n");
        }
    }

    /**
     * Get close request information formatted for HTML.
     */
    private static String getCloseRequestInfoHtml(String channelId) {
        try {
            CloseRequestDAO closeRequestDAO = new CloseRequestDAO();
            CloseRequestDAO.CloseRequestDetails details = closeRequestDAO.getCloseRequestDetails(channelId);

            if (details != null) {
                StringBuilder html = new StringBuilder();
                html.append("<div class='close-info'>\n");
                html.append("<h3>🔒 Close Request Information</h3>\n");
                html.append("<p><strong>Requested by:</strong> &lt;@").append(details.requestedBy).append("&gt;</p>\n");
                html.append("<p><strong>Ticket owner:</strong> &lt;@").append(details.ticketOwner).append("&gt;</p>\n");
                html.append("<p><strong>Reason:</strong> ").append(escapeHtml(details.reason != null ? details.reason : "No reason provided")).append("</p>\n");

                if (details.timeoutHours != null) {
                    html.append("<p><strong>Auto-close timeout:</strong> ").append(details.timeoutHours).append(" hours</p>\n");
                }

                html.append("<p><strong>Status:</strong> ").append(escapeHtml(details.status)).append("</p>\n");

                if (details.createdAt != null) {
                    html.append("<p><strong>Created:</strong> ").append(
                            details.createdAt.toLocalDateTime().atOffset(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER)).append(TIMEZONE_SUFFIX).append("</p>\n");
                }

                if (details.respondedAt != null) {
                    html.append("<p><strong>Responded:</strong> ").append(
                            details.respondedAt.toLocalDateTime().atOffset(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER)).append(TIMEZONE_SUFFIX).append("</p>\n");
                }

                if (details.excludedFromAutoClose) {
                    html.append("<p><strong>⚠️ Excluded from auto-close</strong></p>\n");
                }

                html.append("</div>\n\n");
                return html.toString();
            }
        } catch (Exception e) {
            System.err.println("Could not retrieve close request details for HTML: " + e.getMessage());
        }

        return null;
    }

    /**
     * Process message content to remove unwanted phrases.
     */
    private static String processMessageContent(String content) {
        if (content == null) return "";
        // Remove "Please choose an action:" from message content
        return content.replaceAll("Please choose an action:", "").trim();
    }

    /**
     * Enhance close request information in embed descriptions.
     */
    private static String enhanceCloseRequestInfo(String description) {
        if (description == null) return "";

        // Remove "Please choose an action:"
        description = description.replaceAll("Please choose an action:", "").trim();

        // Add additional parsing for timeout information if needed
        if (description.contains("Original Close Request:")) {
            // Already contains detailed info, just clean it up
            return description;
        }

        return description;
    }

    /**
     * Converts Discord timestamp format <t:timestamp:format> to readable datetime format.
     */
    private static String convertDiscordTimestamps(String text) {
        if (text == null) return null;

        Matcher matcher = DISCORD_TIMESTAMP_PATTERN.matcher(text);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            try {
                long timestamp = Long.parseLong(matcher.group(1));
                LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochSecond(timestamp), TIMEZONE_OFFSET);
                String formattedDate = dateTime.format(TRANSCRIPT_FORMATTER) + TIMEZONE_SUFFIX;
                matcher.appendReplacement(result, formattedDate);
            } catch (NumberFormatException e) {
                matcher.appendReplacement(result, matcher.group(0));
            }
        }
        matcher.appendTail(result);
        return result.toString();
    }

    /**
     * Escape HTML characters for safe display.
     */
    private static String escapeHtml(String input) {
        if (input == null) return "";
        return input.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&#39;")
                .replace("\n", "<br>");
    }

    /**
     * Get file size in human readable format (e.g., 1.2 KB, 5.4 MB).
     */
    public static String getReadableFileSize(long bytes) {
        if (bytes < 1024) return bytes + " B";
        int exp = (int) (Math.log(bytes) / Math.log(1024));
        String pre = "KMGTPE".charAt(exp - 1) + "";
        return String.format("%.1f %sB", bytes / Math.pow(1024, exp), pre);
    }

    /**
     * Enhanced HTTP server for serving HTML transcripts.
     * Includes better error handling, logging, and connection management.
     */
    private static class SimpleHttpServer {
        private final int port;
        private final File htmlFile;
        private final String channelName;
        private java.net.ServerSocket serverSocket;
        private volatile boolean running = false;
        private int boundPort = -1;

        public SimpleHttpServer(int port, File htmlFile, String channelName) {
            this.port = port;
            this.htmlFile = htmlFile;
            this.channelName = channelName;
        }

        public int getBoundPort() {
            return boundPort;
        }

        public boolean isRunning() {
            return running && serverSocket != null && !serverSocket.isClosed();
        }

        public void start() throws Exception {
            try {
                // Try to bind to all interfaces first (0.0.0.0)
                serverSocket = new java.net.ServerSocket(port, 50, java.net.InetAddress.getByName("0.0.0.0"));
                boundPort = serverSocket.getLocalPort();
                System.out.println("🌐 Transcript server bound to 0.0.0.0:" + boundPort + " for channel: " + channelName);
            } catch (java.net.BindException bindEx) {
                System.err.println("⚠️ Bind failed on 0.0.0.0:" + port + " for " + channelName + ", trying localhost");
                try {
                    // Fallback to localhost
                    serverSocket = new java.net.ServerSocket(port, 50, java.net.InetAddress.getByName("127.0.0.1"));
                    boundPort = serverSocket.getLocalPort();
                    System.out.println("🏠 Transcript server bound to 127.0.0.1:" + boundPort + " for channel: " + channelName);
                } catch (Exception innerEx) {
                    // Last resort: use system-assigned port
                    serverSocket = new java.net.ServerSocket(0);
                    boundPort = serverSocket.getLocalPort();
                    System.out.println("🎲 Transcript server bound to ephemeral port " + boundPort + " for channel: " + channelName);
                }
            }

            running = true;
            System.out.println("✅ Transcript server started successfully for " + channelName + " at port " + boundPort);

            // Accept connections
            while (running) {
                try (java.net.Socket clientSocket = serverSocket.accept()) {
                    handleRequest(clientSocket);
                } catch (java.net.SocketException e) {
                    if (running) {
                        System.err.println("⚠️ Socket error for " + channelName + ": " + e.getMessage());
                    }
                    // If server is being stopped, this is expected
                } catch (Exception e) {
                    if (running) {
                        System.err.println("❌ Error handling request for " + channelName + ": " + e.getMessage());
                    }
                }
            }
        }

        public void stop() {
            running = false;
            try {
                if (serverSocket != null && !serverSocket.isClosed()) {
                    serverSocket.close();
                    System.out.println("🛑 Transcript server stopped for: " + channelName);
                }
            } catch (Exception e) {
                System.err.println("❌ Error stopping server for " + channelName + ": " + e.getMessage());
            }
        }

        private void handleRequest(java.net.Socket clientSocket) throws Exception {
            clientSocket.setSoTimeout(10000); // 10 second timeout
            
            try (java.io.OutputStream out = clientSocket.getOutputStream();
                 java.io.BufferedReader in = new java.io.BufferedReader(
                     new java.io.InputStreamReader(clientSocket.getInputStream()))) {

                // Read the request line
                String requestLine = in.readLine();
                if (requestLine == null || requestLine.trim().isEmpty()) {
                    return;
                }

                System.out.println("📝 [" + channelName + "] HTTP Request: " + requestLine);

                // Parse the request
                String[] requestParts = requestLine.split(" ");
                if (requestParts.length < 2) {
                    sendErrorResponse(out, 400, "Bad Request");
                    return;
                }

                String method = requestParts[0];
                String path = requestParts[1];

                // Only handle GET requests
                if (!"GET".equals(method)) {
                    sendErrorResponse(out, 405, "Method Not Allowed");
                    return;
                }

                // Route handling
                if ("/transcript".equals(path)) {
                    serveTranscript(out);
                } else if ("/download".equals(path)) {
                    serveDownload(out);
                } else if ("/".equals(path)) {
                    // Redirect root to transcript
                    sendRedirectResponse(out, "/transcript");
                } else if ("/health".equals(path)) {
                    sendHealthResponse(out);
                } else {
                    sendErrorResponse(out, 404, "Not Found");
                }

            } catch (java.net.SocketTimeoutException e) {
                System.err.println("⏱️ Request timeout for " + channelName);
            }
        }

        private void serveTranscript(java.io.OutputStream out) throws Exception {
            if (!htmlFile.exists()) {
                System.err.println("❌ [" + channelName + "] HTML file not found: " + htmlFile.getAbsolutePath());
                sendErrorResponse(out, 404, "Transcript file not found");
                return;
            }

            System.out.println("📄 [" + channelName + "] Serving transcript file: " + htmlFile.getName() + " (" + htmlFile.length() + " bytes)");

            // Send HTTP headers
            String headers = "HTTP/1.1 200 OK\r\n" +
                           "Content-Type: text/html; charset=UTF-8\r\n" +
                           "Content-Length: " + htmlFile.length() + "\r\n" +
                           "Cache-Control: no-cache, no-store, must-revalidate\r\n" +
                           "Pragma: no-cache\r\n" +
                           "Expires: 0\r\n" +
                           "Access-Control-Allow-Origin: *\r\n" +
                           "\r\n";

            out.write(headers.getBytes(java.nio.charset.StandardCharsets.UTF_8));

            // Send file content
            try (java.io.FileInputStream fis = new java.io.FileInputStream(htmlFile);
                 java.io.BufferedInputStream bis = new java.io.BufferedInputStream(fis)) {
                
                byte[] buffer = new byte[8192]; // 8KB buffer
                int bytesRead;
                while ((bytesRead = bis.read(buffer)) != -1) {
                    out.write(buffer, 0, bytesRead);
                }
            }

            System.out.println("✅ [" + channelName + "] Transcript served successfully");
        }

        private void serveDownload(java.io.OutputStream out) throws Exception {
            if (!htmlFile.exists()) {
                System.err.println("❌ [" + channelName + "] HTML file not found for download: " + htmlFile.getAbsolutePath());
                sendErrorResponse(out, 404, "Transcript file not found");
                return;
            }

            String safeName = htmlFile.getName().replaceAll("[^a-zA-Z0-9._-]", "_");
            String headers = "HTTP/1.1 200 OK\r\n" +
                           "Content-Type: application/octet-stream\r\n" +
                           "Content-Disposition: attachment; filename=\"" + safeName + "\"\r\n" +
                           "Content-Length: " + htmlFile.length() + "\r\n" +
                           "Cache-Control: no-cache, no-store, must-revalidate\r\n" +
                           "Pragma: no-cache\r\n" +
                           "Expires: 0\r\n" +
                           "Access-Control-Allow-Origin: *\r\n" +
                           "\r\n";

            out.write(headers.getBytes(java.nio.charset.StandardCharsets.UTF_8));

            try (java.io.FileInputStream fis = new java.io.FileInputStream(htmlFile);
                 java.io.BufferedInputStream bis = new java.io.BufferedInputStream(fis)) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = bis.read(buffer)) != -1) {
                    out.write(buffer, 0, bytesRead);
                }
            }
            System.out.println("✅ [" + channelName + "] Transcript download served successfully");
        }

        private void sendHealthResponse(java.io.OutputStream out) throws Exception {
            String body = "OK - Transcript server for " + channelName + " is running";
            String response = "HTTP/1.1 200 OK\r\n" +
                            "Content-Type: text/plain; charset=UTF-8\r\n" +
                            "Content-Length: " + body.length() + "\r\n" +
                            "\r\n" +
                            body;
            out.write(response.getBytes(java.nio.charset.StandardCharsets.UTF_8));
        }

        private void sendRedirectResponse(java.io.OutputStream out, String location) throws Exception {
            String response = "HTTP/1.1 302 Found\r\n" +
                            "Location: " + location + "\r\n" +
                            "Content-Length: 0\r\n" +
                            "\r\n";
            out.write(response.getBytes(java.nio.charset.StandardCharsets.UTF_8));
        }

        private void sendErrorResponse(java.io.OutputStream out, int statusCode, String statusText) throws Exception {
            String body = "<html><body><h1>" + statusCode + " " + statusText + "</h1>" +
                         "<p>Transcript server for channel: " + escapeHtml(channelName) + "</p>" +
                         "</body></html>";
            
            String response = "HTTP/1.1 " + statusCode + " " + statusText + "\r\n" +
                            "Content-Type: text/html; charset=UTF-8\r\n" +
                            "Content-Length: " + body.length() + "\r\n" +
                            "\r\n" +
                            body;
            
            out.write(response.getBytes(java.nio.charset.StandardCharsets.UTF_8));
            System.err.println("❌ [" + channelName + "] Sent " + statusCode + " response");
        }
    }
}