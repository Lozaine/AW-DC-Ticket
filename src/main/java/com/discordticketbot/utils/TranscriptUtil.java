package com.discordticketbot.utils;

import net.dv8tion.jda.api.entities.Message;
import net.dv8tion.jda.api.entities.MessageEmbed;
import net.dv8tion.jda.api.entities.MessageReaction;
import net.dv8tion.jda.api.entities.channel.concrete.TextChannel;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Collections;

public class TranscriptUtil {

    // Use UTC+08:00 timezone (Malaysia/Singapore timezone)
    private static final ZoneOffset TIMEZONE_OFFSET = ZoneOffset.ofHours(8);
    private static final String TIMEZONE_SUFFIX = " UTC+08:00";

    // Pattern to match Discord timestamp format <t:timestamp:format>
    private static final Pattern DISCORD_TIMESTAMP_PATTERN = Pattern.compile("<t:(\\d+):[FfDdTtRr]>");
    private static final DateTimeFormatter TRANSCRIPT_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    /**
     * Creates a plain text transcript content from channel messages.
     * This method preserves the old code's format.
     */
    public static String createTranscriptContent(TextChannel channel, List<Message> messages) {
        StringBuilder transcript = new StringBuilder();

        // Sort messages to be in chronological order (oldest first)
        List<Message> sortedMessages = messages.stream()
                .sorted((m1, m2) -> m1.getTimeCreated().compareTo(m2.getTimeCreated()))
                .toList();

        // Header
        transcript.append("=== DISCORD TICKET TRANSCRIPT ===\n");
        transcript.append("Server: ").append(channel.getGuild().getName()).append("\n");
        transcript.append("Channel: ").append(channel.getName()).append("\n");
        transcript.append("Category: ").append(channel.getParentCategory() != null ? channel.getParentCategory().getName() : "None").append("\n");
        transcript.append("Total Messages: ").append(sortedMessages.size()).append("\n");
        transcript.append("Generated: ").append(LocalDateTime.now(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER)).append(TIMEZONE_SUFFIX).append("\n");
        transcript.append("Generated by: Bot System\n");
        transcript.append("=====================================\n\n");

        // Messages
        for (Message msg : sortedMessages) {
            String timestamp = msg.getTimeCreated().atZoneSameInstant(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER);
            transcript.append(String.format("[%s%s] %s: %s\n", timestamp, TIMEZONE_SUFFIX, msg.getAuthor().getName(), msg.getContentDisplay()));

            if (!msg.getEmbeds().isEmpty()) {
                for (MessageEmbed embed : msg.getEmbeds()) {
                    transcript.append("    [EMBED] Title: ").append(embed.getTitle() != null ? embed.getTitle() : "No Title").append("\n");
                    if (embed.getDescription() != null) {
                        String description = convertDiscordTimestamps(embed.getDescription());
                        transcript.append("    [EMBED] Description: ").append(description).append("\n");
                    }
                }
            }

            if (!msg.getAttachments().isEmpty()) {
                for (Message.Attachment attachment : msg.getAttachments()) {
                    transcript.append("    [ATTACHMENT] ").append(attachment.getFileName())
                            .append(" (").append(getReadableFileSize(attachment.getSize())).append(")")
                            .append(" - ").append(attachment.getUrl()).append("\n");
                }
            }

            if (!msg.getReactions().isEmpty()) {
                transcript.append("    [REACTIONS] ");
                for (MessageReaction reaction : msg.getReactions()) {
                    transcript.append(reaction.getEmoji().getName()).append(":").append(reaction.getCount()).append(" ");
                }
                transcript.append("\n");
            }
            transcript.append("\n");
        }

        // Footer
        transcript.append("=== END OF TRANSCRIPT ===\n");
        return transcript.toString();
    }

    /**
     * Saves the plain text transcript to a file.
     * Retained from the old code.
     */
    public static File saveTranscriptToFile(TextChannel channel, String content) throws IOException {
        File transcriptsDir = new File("transcripts");
        if (!transcriptsDir.exists()) transcriptsDir.mkdirs();

        String fileName = String.format("%s_%s.txt",
                channel.getName(),
                LocalDateTime.now(TIMEZONE_OFFSET).format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss")));

        File transcriptFile = new File(transcriptsDir, fileName);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(transcriptFile))) {
            writer.write(content);
        }
        System.out.println("Transcript saved: " + transcriptFile.getAbsolutePath());
        return transcriptFile;
    }

    /**
     * Create HTML transcript (more advanced formatting).
     * This is the new functionality from the new code.
     */
    public static String createHtmlTranscript(TextChannel channel, List<Message> messages) {
        StringBuilder html = new StringBuilder();

        List<Message> sortedMessages = messages.stream()
                .sorted((m1, m2) -> m1.getTimeCreated().compareTo(m2.getTimeCreated()))
                .toList();

        // HTML header and CSS styles
        html.append("<!DOCTYPE html>\n<html>\n<head>\n");
        html.append("<meta charset='UTF-8'>\n");
        html.append("<title>Ticket Transcript - ").append(channel.getName()).append("</title>\n");
        html.append("<style>\n");
        html.append("body { font-family: 'Segoe UI', Arial, sans-serif; background: #36393f; color: #dcddde; margin: 0; padding: 20px; }\n");
        html.append(".header { background: #2f3136; padding: 20px; border-radius: 8px; margin-bottom: 20px; }\n");
        html.append(".message { margin-bottom: 15px; padding: 10px; background: #40444b; border-radius: 8px; }\n");
        html.append(".author { font-weight: bold; color: #ffffff; margin-bottom: 5px; }\n");
        html.append(".timestamp { color: #72767d; font-size: 12px; margin-left: 10px; }\n");
        html.append(".content { margin-top: 5px; line-height: 1.4; }\n");
        html.append(".bot-tag { background: #5865f2; color: white; padding: 2px 4px; border-radius: 3px; font-size: 10px; }\n");
        html.append(".embed { border-left: 4px solid #5865f2; padding: 10px; margin: 10px 0; background: #2f3136; }\n");
        html.append(".attachment { color: #00b0f4; text-decoration: underline; }\n");
        html.append("</style>\n");
        html.append("</head>\n<body>\n");

        // Header
        html.append("<div class='header'>\n");
        html.append("<h1>Ticket Transcript</h1>\n");
        html.append("<p><strong>Channel:</strong> ").append(channel.getName()).append(" (").append(channel.getId()).append(")</p>\n");
        html.append("<p><strong>Guild:</strong> ").append(channel.getGuild().getName()).append("</p>\n");
        html.append("<p><strong>Generated:</strong> ").append(java.time.LocalDateTime.now(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER)).append(TIMEZONE_SUFFIX).append("</p>\n");
        html.append("<p><strong>Total Messages:</strong> ").append(sortedMessages.size()).append("</p>\n");
        if (channel.getTopic() != null && !channel.getTopic().isEmpty()) {
            html.append("<p><strong>Ticket Owner:</strong> ").append(channel.getTopic()).append("</p>\n");
        }
        html.append("</div>\n\n");

        // Messages
        for (Message message : sortedMessages) {
            html.append("<div class='message'>\n");
            html.append("<div class='author'>").append(escapeHtml(message.getAuthor().getAsTag()));

            if (message.getAuthor().isBot()) {
                html.append(" <span class='bot-tag'>BOT</span>");
            }

            html.append("<span class='timestamp'>")
                    .append(message.getTimeCreated().atZoneSameInstant(TIMEZONE_OFFSET).format(TRANSCRIPT_FORMATTER))
                    .append(TIMEZONE_SUFFIX)
                    .append("</span></div>\n");

            String content = message.getContentDisplay();
            if (!content.isEmpty()) {
                html.append("<div class='content'>").append(escapeHtml(content)).append("</div>\n");
            }

            for (var embed : message.getEmbeds()) {
                html.append("<div class='embed'>\n");
                if (embed.getTitle() != null) {
                    html.append("<strong>").append(escapeHtml(embed.getTitle())).append("</strong><br>\n");
                }
                if (embed.getDescription() != null) {
                    html.append(escapeHtml(embed.getDescription())).append("\n");
                }
                html.append("</div>\n");
            }

            for (var attachment : message.getAttachments()) {
                html.append("<div class='content'>");
                html.append("<a href='").append(attachment.getUrl()).append("' class='attachment' target='_blank'>");
                html.append("ðŸ“Ž ").append(escapeHtml(attachment.getFileName()));
                html.append("</a></div>\n");
            }
            html.append("</div>\n\n");
        }

        // Footer
        html.append("<div class='header'>\n");
        html.append("<p><em>Generated by Discord Ticket Bot</em></p>\n");
        html.append("</div>\n");
        html.append("</body>\n</html>");

        return html.toString();
    }

    /**
     * Saves the HTML transcript to a file.
     * This is the new functionality from the new code.
     */
    public static File saveHtmlTranscriptToFile(TextChannel channel, String htmlContent) throws IOException {
        File transcriptsDir = new File("transcripts");
        if (!transcriptsDir.exists()) {
            transcriptsDir.mkdirs();
        }

        String timestamp = java.time.LocalDateTime.now(TIMEZONE_OFFSET).format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
        String filename = String.format("%s_%s_%s.html",
                channel.getName(),
                channel.getId(),
                timestamp);

        File transcriptFile = new File(transcriptsDir, filename);

        try (FileWriter writer = new FileWriter(transcriptFile)) {
            writer.write(htmlContent);
        }

        System.out.println("âœ… HTML transcript saved: " + transcriptFile.getAbsolutePath());
        return transcriptFile;
    }

    /**
     * Appends close request information to the transcript if available.
     * This method is a placeholder from the old code.
     */
    private static void appendCloseRequestInfo(String channelId, StringBuilder transcript) {
        // TODO: Implement logic to fetch and append close request details from your database.
    }

    /**
     * Converts Discord timestamp format <t:timestamp:format> to readable datetime format.
     * Retained from the old code.
     */
    private static String convertDiscordTimestamps(String text) {
        if (text == null) return null;

        Matcher matcher = DISCORD_TIMESTAMP_PATTERN.matcher(text);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            try {
                long timestamp = Long.parseLong(matcher.group(1));
                LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochSecond(timestamp), TIMEZONE_OFFSET);
                String formattedDate = dateTime.format(TRANSCRIPT_FORMATTER) + TIMEZONE_SUFFIX;
                matcher.appendReplacement(result, formattedDate);
            } catch (NumberFormatException e) {
                matcher.appendReplacement(result, matcher.group(0));
            }
        }
        matcher.appendTail(result);
        return result.toString();
    }

    /**
     * Escape HTML characters for safe display.
     * This is a new helper method from the new code.
     */
    private static String escapeHtml(String input) {
        if (input == null) return "";
        return input.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&#39;")
                .replace("\n", "<br>");
    }

    /**
     * Get file size in human readable format (e.g., 1.2 KB, 5.4 MB).
     * This is the more robust method from the new code.
     */
    public static String getReadableFileSize(long bytes) {
        if (bytes < 1024) return bytes + " B";
        int exp = (int) (Math.log(bytes) / Math.log(1024));
        String pre = "KMGTPE".charAt(exp - 1) + "";
        return String.format("%.1f %sB", bytes / Math.pow(1024, exp), pre);
    }
}